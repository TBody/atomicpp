!    -*- f90 -*-
! Author: Pearu Peterson <pearu@cens.ioc.ee>
!
! All Fortran functions are marked as thread safe.
! They do not contain any DATA, SAVE, COMMON or EQUIVALENCE statements
! and do not allocate any local arrays larger than 160 bytes.
! In current versions of gfortran, local variables smaller than 32768 bytes
! are allocated on the stack by default.
! This limit can be overridden with -fmax-stack-var-size, or -frecursive can
! be used to force all local arrays to be allocated on the stack.
!
python module dfitpack ! in

  usercode '''

static double dmax(double* seq,int len) {
  double val;
  int i;
  if (len<1)
    return -1e308;
  val = seq[0];
  for(i=1;i<len;++i)
    if (seq[i]>val) val = seq[i];
  return val;
}
static double dmin(double* seq,int len) {
  double val;
  int i;
  if (len<1)
    return 1e308;
  val = seq[0];
  for(i=1;i<len;++i)
    if (seq[i]<val) val = seq[i];
  return val;
}
static double calc_b(double* x,int m,double* tx,int nx) {
  double val1 = dmin(x,m);
  double val2 = dmin(tx,nx);
  if (val2>val1) return val1;
  val1 = dmax(tx,nx);
  return val2 - (val1-val2)/nx;
}
static double calc_e(double* x,int m,double* tx,int nx) {
  double val1 = dmax(x,m);
  double val2 = dmax(tx,nx);
  if (val2<val1) return val1;
  val1 = dmin(tx,nx);
  return val2 + (val2-val1)/nx;
}
static int imax(int i1,int i2) {
  return MAX(i1,i2);
}

static int calc_surfit_lwrk1(int m, int kx, int ky, int nxest, int nyest) {
 int u = nxest-kx-1;
 int v = nyest-ky-1;
 int km = MAX(kx,ky)+1;
 int ne = MAX(nxest,nyest);
 int bx = kx*v+ky+1;
 int by = ky*u+kx+1;
 int b1,b2;
 if (bx<=by) {b1=bx;b2=bx+v-ky;}
 else {b1=by;b2=by+u-kx;}
 return u*v*(2+b1+b2)+2*(u+v+km*(m+ne)+ne-kx-ky)+b2+1;
}
static int calc_surfit_lwrk2(int m, int kx, int ky, int nxest, int nyest) {
 int u = nxest-kx-1;
 int v = nyest-ky-1;
 int bx = kx*v+ky+1;
 int by = ky*u+kx+1;
 int b2 = (bx<=by?bx+v-ky:by+u-kx);
 return u*v*(b2+1)+b2;
}

static int calc_spherfit_lwrk1(int m, int ntest, int npest) {
 int u = ntest-7;
 int v = npest-7;
 return 185+52*v+10*u+14*u*v+8*(u-1)*v*v+8*m;
}
static int calc_spherfit_lwrk2(int ntest, int npest) {
 int u = ntest-7;
 int v = npest-7;
 return 48+21*v+7*u*v+4*(u-1)*v*v;
}

static int calc_regrid_lwrk(int mx, int my, int kx, int ky,
                            int nxest, int nyest) {
 int u = MAX(my, nxest);
 return 4+nxest*(my+2*kx+5)+nyest*(2*ky+5)+mx*(kx+1)+my*(ky+1)+u;
}
'''

  interface

     subroutine fpchec(x,m,t,n,k,ier)
       threadsafe
       real*8 dimension(m),intent(in) :: x
       integer intent(hide),depend(x) :: m=len(x)
       real*8 dimension(n),intent(in) :: t
       integer intent(hide),depend(t) :: n=len(t)
       integer :: k
       integer intent(out) :: ier
     end subroutine fpchec

     !!!!!!!!!! Bivariate spline !!!!!!!!!!!

     subroutine bispeu(tx,nx,ty,ny,c,kx,ky,x,y,z,m,wrk,lwrk,ier)
       ! z,ier = bispeu(tx,ty,c,kx,ky,x,y)
       threadsafe
       real*8 dimension(nx),intent(in) :: tx
       integer intent(hide),depend(tx) :: nx=len(tx)
       real*8 dimension(ny),intent(in) :: ty
       integer intent(hide),depend(ty) :: ny=len(ty)
       real*8 intent(in),dimension((nx-kx-1)*(ny-ky-1)),depend(nx,ny,kx,ky),&
            check(len(c)==(nx-kx-1)*(ny-ky-1)):: c
       integer :: kx
       integer :: ky
       real*8 intent(in),dimension(m) :: x
       real*8 intent(in),dimension(m) :: y
       integer intent(hide),depend(x) :: m=len(x)
       real*8 dimension(m),depend(m),intent(out,c) :: z
       real*8 dimension(lwrk),depend(lwrk),intent(hide,cache) :: wrk
       integer intent(hide),depend(kx,ky) :: lwrk=kx+ky+2
       integer intent(out) :: ier
     end subroutine bispeu

     subroutine regrid_smth(iopt,mx,x,my,y,z,xb,xe,yb,ye,kx,ky,s,&
        nxest,nyest,nx,tx,ny,ty,c,fp,wrk,lwrk,iwrk,kwrk,ier)
       !  nx,tx,ny,ty,c,fp,ier = regrid_smth(x,y,z,[xb,xe,yb,ye,kx,ky,s])

       fortranname regrid
       threadsafe

       integer intent(hide) :: iopt=0
       integer intent(hide),depend(x,kx),check(mx>kx) :: mx=len(x)
       real*8 dimension(mx) :: x
       integer intent(hide),depend(y,ky),check(my>ky) :: my=len(y)
       real*8 dimension(my) :: y
       real*8 dimension(mx*my),depend(mx,my),check(len(z)==mx*my) :: z
       real*8 optional,depend(x,mx) :: xb=dmin(x,mx)
       real*8 optional,depend(x,mx) :: xe=dmax(x,mx)
       real*8 optional,depend(y,my) :: yb=dmin(y,my)
       real*8 optional,depend(y,my) :: ye=dmax(y,my)
       integer optional,check(1<=kx && kx<=5) :: kx = 3
       integer optional,check(1<=ky && ky<=5) :: ky = 3
       real*8 optional,check(0.0<=s) :: s = 0.0
       integer intent(hide),depend(kx,mx),check(nxest>=2*(kx+1)) &
            :: nxest = mx+kx+1
       integer intent(hide),depend(ky,my),check(nyest>=2*(ky+1)) &
            :: nyest = my+ky+1
       integer intent(out) :: nx
       real*8 dimension(nxest),intent(out),depend(nxest) :: tx
       integer intent(out) :: ny
       real*8 dimension(nyest),intent(out),depend(nyest) :: ty
       real*8 dimension((nxest-kx-1)*(nyest-ky-1)), &
            depend(kx,ky,nxest,nyest),intent(out) :: c
       real*8 intent(out) :: fp
       real*8 dimension(lwrk),intent(cache,hide),depend(lwrk) :: wrk
       integer intent(hide),depend(mx,my,kx,ky,nxest,nyest) &
            :: lwrk=calc_regrid_lwrk(mx,my,kx,ky,nxest,nyest)
       integer dimension(kwrk),depend(kwrk),intent(cache,hide) :: iwrk
       integer intent(hide),depend(mx,my,nxest,nyest) &
            :: kwrk=3+mx+my+nxest+nyest
       integer intent(out) :: ier
     end subroutine regrid_smth
     
  end interface
end python module dfitpack

